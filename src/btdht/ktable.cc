#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <assert.h>
#include <arpa/inet.h>
#include <netinet/in.h>

/*#include "kitem.h"*/
#include "btkad.h"
#include "knode.h"
#include "kbucket.h"
#include "ktable.h"

static int
bit1_start_at(const char *target)
{
    int i;
    int index = 0;
    uint8_t midx = 0xFF;
    static const uint8_t mtable[] = {
        0x8, 0x7, 0x6, 0x6, 0x5, 0x5, 0x5, 0x5, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 
        0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
        0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 
        0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 
        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 
        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 
        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 
        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
    };
    for (i=0; i<20&&midx==0; i++){
        midx = (uint8_t)target[i];
        int delta = mtable[midx];
        index += delta;
    }
    return index;
}

int ktable::invalid_node(const kitem_t *in)
{
    return 0;
}

int
ktable::bit1_index_of(const char *target)
{
    char shadow[20];
    memcpy(shadow, target, 20);
    b_node0->XOR(shadow);
    return bit1_start_at(shadow);
}

int
ktable::find_nodes(const char target[20], kitem_t items[8])
{
    int i;
    int count = 0;
    int offset = bit1_index_of(target);

    kitem_t vitems[8];
    int backoff = offset>b_nbucket1?b_nbucket1:offset;
    for (i=offset; i<b_nbucket1; i++){
        int n = b_buckets[i].find_nodes(vitems);
        if (n+count >= 8){
            memcpy(&items[count], vitems, sizeof(kitem_t)*(count-8));
            count = 8;
            break;
        }
        memcpy(&items[count], vitems, sizeof(kitem_t)*n);
        count += n;
    }
    for (i=backoff-1; i>=0; i--){
        int n = b_buckets[i].find_nodes(vitems);
        if (n+count >= 8){
            memcpy(&items[count], vitems, sizeof(kitem_t)*(count-8));
            count = 8;
            break;
        }
        memcpy(&items[count], vitems, sizeof(kitem_t)*n);
        count += n;
    }
    return count;
}

int
ktable::insert_node(const kitem_t *in, kitem_t *out)
{
    kbucket *bucket;
    const char *kadid = in->kadid;
    int nbucket1 = bit1_index_of(kadid);
    int index = nbucket1++;

    if (nbucket1 > 160){
        printf("internal error!\n");
        return 0;
    }

    if (nbucket1 > b_nbucket1){
        b_nbucket1 = nbucket1;
    }

    b_count0++;
    for (; b_count0>8; b_nbucket0++){
        kitem_t items[_K];
        int j = b_nbucket0;
        assert(j<b_nbucket1);
        b_count0 -= b_buckets[j].find_nodes(items);
    }
    if (index < b_nbucket0){
        b_count0--;
    }
    return b_buckets[index].update_contact(in, out);
}

ktable::ktable(knode *node)
    :b_count0(0), b_node0(new knode(*node))
{
    b_buckets = new kbucket[160];
}

ktable::~ktable()
{
    delete b_node0;
    delete[] b_buckets;
}
